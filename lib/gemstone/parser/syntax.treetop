module Gemstone
  module Parser
    grammar Syntax

      rule program
        blank? bare_block {
          def sexp
            bare_block.sexp
          end
        }
      end

      rule line
        comment / statement / nothing
      end

      rule nothing
        "" {
          def sexp
            nil
          end
        }
      end

      rule comment
        '#' [^\n]* { 
          def sexp
            nil
          end
        }
      end

      rule statement
        method_definition / primitive / expression
      end

      rule method_definition
        'def' blank target:variable_or_method_name '.' method_name:variable_or_method_name blank body:block_without_header {
          def sexp
            [:send,
              [:send, :kernel, [[:pi_lit_str, "lvar_get"], [:pi_lit_str, target.text_value]]],
              [
                [:pi_lit_str, "define_method"],
                [:pi_lit_str, method_name.text_value],
                [:ps_push_lambda, body.sexp]
              ]
            ]
          end
        }
      end

      rule block_without_header
        bare_block "end" {
          def sexp
            bare_block.sexp
          end
        }
      end

      rule bare_block
        head:line tail:(blank l:line)* {
          def sexp
            lines = [head] + tail.elements.map{|e|e.l}
            out = [:pb_block]
            lines.each do |s|
              $stderr.puts "parsing line:", s.inspect

              out << s.sexp unless s.sexp.nil?
            end
            out
          end
        }
      end

      rule expression
        lvar_assignment
        /
        string_literal
        /
        method_call
      end

      rule method_call
        target:(name:variable_or_method_name ".")? method:variable_or_method_name optional_arg:(blank arg:expression)? {
          def sexp
            has_target = target.respond_to?(:name)
            has_arg = optional_arg.respond_to?(:arg)
            if !has_target and !has_arg
              return [:send, :kernel, [[:pi_lit_str, "lvar_get"], [:pi_lit_str, method.text_value]]]
            end

            if has_arg
              argz = [[:pi_lit_str, method.text_value], optional_arg.arg.sexp]
            else
              argz = [[:pi_lit_str, method.text_value]]
            end

            if has_target
              [:send,
                [:send, :kernel, [[:pi_lit_str, "lvar_get"], [:pi_lit_str, target.name.text_value]]],
                argz
              ]
            else
              [:send, :kernel, argz]
            end
          end
        }
      end

      rule lvar_assignment
        variable_or_method_name blank? '=' blank? expression {
          def sexp
            [:send, :kernel, [[:pi_lit_str, "lvar_assign"], [:pi_lit_str, variable_or_method_name.text_value], expression.sexp]]
          end
        }
      end

      rule primitive
        "Gemstone.primitive" blank symbol {
          def sexp
            [symbol.name.to_sym]
          end
        }
      end

      rule blank
        [ \n]+
      end

      rule string_literal
        ['"] chars:[^'"]* ["'] {
          def sexp
            [:pi_lit_str, chars.text_value]
          end
        }
      end

      rule variable_or_method_name
        !"end" [a-zA-Z_] [a-zA-Z_0-9]*
      end

      rule symbol
        ':' chars:[a-zA-Z_]+ {
          def name
            chars.text_value
          end
        }
      end
    end
  end
end